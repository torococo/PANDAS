numpy{ 
  ndarray{
    properties{
      shape tuple (dimensions)
      dtype{
        normal{
          [int8,16,32,64][uint8,16,32,64][float16,32,64,128][complex64,128,256][bool][object][string_][unicode_]
          string and unicode have a number after denoting max length in bytes/chars
        }
        abbreviated{
          [i1,2,4][u1,2,4][f2,f4(or f),f8(or d),f16(or g)][c8,16,32][?][O][S_][U_]
        }
      }
    }
    functions{
      constructors{
        array(sequence-like object){
          produces a new ndarray
          nested produces multidimensional
        }
        asarray(sequence-like-object){
          converts to ndarray, but if already is an ndarray, does not change
        }
        copy{
          creates separate array copy (not a view)
        }
        zeros,ones,eye,empty{
          creates arrays of all zeros/ones/identity/uninitialized
        }
        arange(int){similar to range in python, creates range of numbers}
        ones_like/zeros_like/empty_like{
          produces an array of ones/zeros that is of same dims as arg
        }
        astype{
          converts from one dtype to another
          ALWAYS returns new array, even if type is same
        }
      }
      operations{
        elementwise{
          +,-,*,/,**,mod works for scalars
          can also do elementwise boolean comparisons, returns a boolean array
          unary ufuncs{
            perform elementwise ops on data in ndarrays
            sqrt,exp,abs/fabs,exp,log,sign,ceil,floor,rint,isnan,isfinite,isinf,-(logical not)
            sin,cos,tan,sinh,cosh,tanh,arccos,...
          }
          binary ufuncs{
            takes 2 arrays, elementwise ops
            +,-,*,/,floor_divide,**,maximum,fmax,minimum,fmin,mod,modf,copysign,>,<,&,|,^...(logical operators)
          }
        }
        reductions{
          mean,sum,std,(can give optional axis arg),any,all
        }
        Special cases{
          cumsum(axis),cumprod(axis) do cumulative functions along give axis
          arr.sort() sorts in place, np.sort(arr) returns sorted copy
          where(cond,ifTrue,ifFalse)
          Set functions{
            unique() returns sorted array of all unique elems
            intersect1d(x,y),union1d(x,y),setdiff1d(x,y),setxor1d(x,y)
            in1d(x,y) boolean array saying if each elem of x is contained in y
          }
        }
      }
      indexing/slicing{
        basics{
          NOTE{slices are just views, not copies!}
          each element is its own array
          arr[2] gets 3rd subarray
          arr[2][0]/arr[2,0] gets first elem of 3rd subarray
          slices work by same analog as access, 
        }
        can use boolean array for slicing as well{
          always returns new array
          can set with boolean arrays as well{
            data[data<5]=0 will set all values < 5 to 0
          }
        }
        fancy{
          arr[[3,2,1,4]]gets subarrays 3,2,1,4 as new array
          arr[[1,2,3],[1,2,3]]gets diagonal elements, basically
          arr[np.ix_([i1,i2...],[j1,j2...])] gets matrix formed by selecting those rows and columns
          always returns new array
        }
        reshape{
          reshapes. contiguous elements go in first dimension, with second dimension subarrays
        }
        transpose{
          can use either .transpose() or .T
          swapaxes can be used for higher dimensional transposing
        }
      }
      saving/loading{
        np.save,np.load
        saves with .npy extension
        np.savez('name.npz',a=arr1,b=arr2) pass arrays as key word arguments
        key word args used to get values out of dict created when loading
        np.savetxt,np.loadtxt,np.genfromtxt
      }
      linear algebra{
        dot,inv,diag,trace,det,eig,inv,pinv,qr,svd,solve,lstsq
      }
      random{
        normal(dist),seed,permutation,shuffle,rand,randint,binomial,beta,chisquare,gamma,uniform

      }
    }
  }
}




pandas{ 
  imports{
    from pandas import Series,DataFrame
    import pandas as pd
  }
  SeriesAndDataFrames{
    functions{
      reindex([],method) returns reindexed version, 
      reindex(columns=[],method) reindexes columns
        fills(with NaNs in missing positions by default)
        methods{
          ffill/pad will carry values forward
          bfill/backfill will carry values backward
        }
      fill_value arg substitutes something else instead of NaN
    }
  }
  Series{
    properties{
      names{
        both the series and index have names, which can be set with:
        obj.name='name',obj.index.name='name2'
      }
      index{
        array of associated labels for each entry of series
        defaults to an array [0...N-1]
      }
    }
    constructors{
      Series([data],[indices])
      Series({dict}) will autosort keys
      Series(prevSeries,[new indices]) will create a new series from the prev w new indices, missing values will be NaN
    }
    operations{
      indexing{
        can use dict notation with index
        numpy array slicing/indexing operations also work (with integers)
        can also use dot notation for index
      }
      math operations{
        similar to numpy arrays, but will line up differently indexed data for math operations
      }
    }
  }
  DataFrames{
    properties{
      columns are names of columns
      .columns gets the columns
      index are names of rows
      .index gets row names
      2D array of data
      indices and columns can also have name attributes
    }
    constructors{
      DataFrame({'a':[1,2,3],'b':['i','j','k']}) with dict
      Array, default columns and indices will be numbers starting at 0
      dict of dicts, dict of Series, first set of keys will be cols, second set will be indices, values become cols
      list of Series: values become rows, indices become column headers
    }
    indexing/slicing{
      columns{
        ditionary or dot notation
        works for columns
      }
      rows{
        .ix used to get row based on index
      }
    }
    assignment{
      single value to column (which will duplicate for each row)
      range of values can also be used (must have correct number of entries)
    }
    deletion{
      del frame['col']
    }
  }
  Index{
    immutable, automatically generated by dataframes and series. hold axis labels
    functions{
      (returns new index)append,diff,intersection,union,delete,drop,insert,unique
      (returns bool)isin,is_monotonic,is_unique
    }
  }
  Functions{
    isnull,notnoull used to check for nulls
  }
}
  matplotlib{
    produces 2d plots and visualizations
  }
  IPython{
    (may not be necissary)
  }
  SciPy{
    numpy and scipy work together to cover most standard scientific computing issues
  }
}

builtin to python{
  (defaultdict(type)){
    pass in a type, like list or int, to create an empty dict whose values are of that type. whenever a new key/value pair is given, the defaultdict will automatically create/append
  }
}
